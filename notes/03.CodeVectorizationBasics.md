# Основы векторизации кода

Цель занятия: Получение знаний и умений по написанию кода на языке высокого уровня для *современных* архитектур CPU.

## Показатели качества кода

Показатели, которые сказываются на пользователя:
1. Производительность кода (performance) -- количественный показатель
    1. Производительность участка кода `1 / T` (c<sup>-1</sup>)
2. Потребляемая память Mem (memory consumption) -- количественный показатель
3. Поддержка современных микроархитектур – качественный
показатель

Показатели, которые относятся к разработчику:
1. Сложность кода Сompl (code complexity) – количественный показатель
2. Число строк кода LOC (Lines of a code)
3. Цикломатическая сложность кода Cycl (cyclomatic complexity of a code) -- количество линейно независимых маршрутов через программный код

## Эффективность кода

Эффективность кода Prod (code productivity) -- отношение производительности к сложности кода. Из этого следует, что написание более сложного (длинного) кода при той же производительности приводит к худшей эффективности.

В знаменатель можно поставить потребляемую память, либо время выхода на рынок, стоимость разработки...

## Эффективность процессора

Эффективность это отношение производительности (к примеру, число операций с плавающей точкой) на рассеиваемую мощность (TDP).

В знаменатель можно поставить стоимость, влияние на окружающую среду...

## Архитектуры SIMD

Поддержка инструкций имеет вложенный характер:
- Intel MMX (64 бита)
- AMD 3DNow! (64 бита)
- SSE Поточное расширение SIMD (64 бит)
- SSE2 (64 бит)
- SSE3 (64 бит) поддержка как от AMD так и от Intel
- SSE4 (128 бит) поддержка от AMD и Intel
- AVX расширенные векторные инструкции (256 бит) поддержка от AMD и Intel (серверные решения)
- AVX2 (256 бит + AES) поддержка от AMD и Intel
- AVX512 (512 бит) поддержка и Intel

## Примеры векторизации

Для задействования векторизации, нужно загрузить один векторный операнд, потом другой (маршаллинг), выполнить векторную инструкцию, и получить результат в векторный регистр, и оттуда в ОЗУ. При последовательном коде, это было бы 4 операции.

## Трансформация кода

Разворачивание циклов (unroll).

При векторизации может меняться не только порядок операций, но и порядок операторов.

### Чтение-после-записи

```c++
// A = 0;
for (j=1;j<=MAX;j++)
    A[j] = A[j-1] + 1;
```

Чтобы устранить зависимость между итерациями:
1. Первые 4 итерации выполняются последовательно.
2. На следующих итерациях, векторно к каждому значению из четвёрки выполняется `+ 4`.
3. Для "хвостика" (не кратного 4), так же выполняется последовательно.

### Запись-после-чтения

```c++
// A = [0, 1, 2, 3, 4];
for (j=1;j<=MAX;j++)
    A[j-1] = A[j] + 1;
```

Распараллеливать этот код с помощью OpenMP невозможно. Но легко решается векторизацией.

## Успешная векторизация

Вывод журнала векторизации `-ftree-vectorizer-verbose=2`.

```sh
$ gcc -c -O3 -march=native -std=c99 -mfpmath=sse -ftree-vectorizer-verbose=2 vector.c
```

Тут может возникнуть перекрытие по памяти (memory overlapping). Начиная с C99 для защиты от этой ситуации используется квалификатор `restrict`.

Некоторые компиляторы делают в такой ситуации автоматическую диспетчеризацию: одну с прямым классическим подходом (amd64), а одну с векторизацией. Минут такого подхода в большем шансе кэш-промахов и худшем предсказании кода.

## ДЗ: Что будет, если к десяти миллиардам (float) добавить пять?

Если разложить число `10'000'000'000` на мантиссу и степень (IEEE754), то мы получим следующий результат:
- знак = `0x0` (положительное число);
- экспонента = `0xA0`;
- мантисса = `0x1502F9`.  
Если мантиссу увеличить на `1` (`0x1502FA`), а потом привести число снова к десятичному виду, то получится `10'000'001'024.000'000`.

Таким образом получается, что имея ограничение точности в 24 бита, на таком масштабе чисел мы будем получать округление до 1024. Если мы добавим 5, то ответом будет снова `10'000'000'000`, а если добавим 600, то получим `10'000'001'024`.