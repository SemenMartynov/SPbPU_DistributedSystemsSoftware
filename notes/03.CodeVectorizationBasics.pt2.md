# Основы векторизации кода (продолжение)

## Успешная векторизация

Решение проблемы перекрытия данных

Генерация диспетчеризуемого кода приводит к увеличению кэш-промохов.

Решения в языках:
- Fortran не допускает ситуации
- C++ умные указатели
- C обещания в виде квалификатора `restrict`.

## Как векторизцется цикл?

Не каждая 4-ка (8-ка, 16-ка) может стать операндом в векторной инструкции. Это связано с ограничениями процессоров: в векторизации могут участвовать данные, которые выравнены по определённому адресу (адрес должен делиться на 16, на 32).

Цикл делиться на 3 части:
- пролог (peel loop) -- не выравненные адреса, будут обрабатываться старыми инструкциями. Таким образом, мы "проматываем" данные до тех пор, пока не обнаружим данные по выравненному адресу.
- векторная часть -- данные обрабатываются векторными инструкциями (к примеру, AVX2)
- эпилог (remainder loop) -- оставшиеся элементы, которые так же обрабатываются классическим образом.

Если данные выравниваются на 64, то при одинарной точности (float) в худшем случае придётся "промотать" 15 значений (60 / 4 ).

Инструкции векторизации предыдущих поколений требовали меньшего выравнивания, значит пролог и эпилог могут быть векторизованы этими инструкциями.

## Различия для разных типов

Рассмотрим 256 бит (AVX1, AVX2). В них можно разместить:
- 8 значений одинарной точности (целые или вещественные)
- 4 целочисленных по 8 байт или 4 вещественных двойной

Такие операции измеряются процессорным циклом, что не привязывает нас к характеристикам процессора, типа его частоты.

При обработке, положим, цикла из 26 int:
- можно ничего не делать, тогда какое-то количество циклов попадёт в пролог (допустим 3), какое-то в реальную веткоризацию (5) и какое-то в эпилог (3)
- можно выравнять начало цикла по нужному адресу, тогда в пролог ничего не попадёт (0), сразу начнётся реальная веткоризация (6) и что-то попадёт в эпилог (2)
- добавить дополнительно в конце отступы (padding), тогда всё будет обработано за 7 циклов. Большее число данных будет обработано за меньшее количество тактов.

## Способы выравнивания

Компилятор может сообщать о том, что данные нужно выравнивать

Выравнивнивание данных:
- `void* _mm_maloc(int size, int n)` выделение памяти с выравниванием
- `int posix_memalign(void **p, size_t n, size_t size)` выравнивание через Posix
- `__declspec(align(n)) array` директивы компилятора

Можно сообщить компилятору, что данные выравнены `#pragma vector aligned`

## Выравнивание строк

В языках C и C++ разворачивание в матрице идёт вначале по второму элементу (номер столбца) а потом по первому (номер строки). Необходимо наращивать число столбцов для выравнивания адресов.

```c
#define COLBUF 1
//...
#define COLWIDTH COL+COLBUF

FTYPE a[ROW][COLWIDTH] __attribute__ ((aligned(16)));
FTYPE b[ROW]           __attribute__ ((aligned(16)));
FTYPE x[COLWIDTH]      __attribute__ ((aligned(16)));
```

## Провалы производительности

Когда данные перестают влезать в очередной уровень кэш-памяти, это ставится заметно на графике производительности.

Решение -- организация блочной работы с СОЗУ (сверх оперативным запоминающим устройством). Можно добавить дополнительный цикл, который будет обрабатывать данные только те, что попадают в кэш.

## Условия векторизации

Для векторизации необходимо:
- Данные должны быть сплошными в памяти (массивы, вектора, специально закодированные графы с избыточностью)
- должен быть обеспечен регулярный доступ к памяти (пример с двумерными массивами)
- Первый элемент каждого вектора должен быть выровнен (избавляемся от пролога)
- Не должно быть перекрытий по памяти (умные указатели)
- Не должно быть зависимостей итераций в виде чтение-после-записи

Ускорение производительности определяется как произведение от эффекта многоядерности и эффекта векторизации.