# Проблемы высокопроизводительных вычислений

Эти "проблемы" решаются не путём вливания средства в аппаратные решения, а путём изысканий.

## Проблема стены памяти (Memory-wall problem)

ЦПУ и ОЗУ -- раздельные устройства.

Если данные есть в кэш-памяти, то можно выполнить порядка 10'000 - 100'000 операций. Либо за всё это время 1 раз сходить в оперативную память и получить их там.

Горловина Фон-Неймана (The von Neumann bottleneck) -- разрыв между производительностью вычислительных элементов и подсистемы памяти.

Рост разницы ожидается ещё больше. В серверных решениях оперативную память размещают в одном корпусе с ЦПУ для уменьшения задержек шины (interconnect), но это приводит к проблеме повышения температуры.

### Анализ ПВЛ каждой операции чтения/запись

Пространственно-временная локализация обращений в память

Профиль работы приложения:
- Чем более беспорядочные обращения к памяти делает приложение, тем больше вероятность возникновения кэш-промахов. Это считается плохой SL.
- Если обращения идут последовательно, то это хорошая SL.

Многомерные массивы:
- https://www.codeproject.com/Articles/83080/Dynamic-Three-Dimensional-Arrays-in-C-C-C-Java
- https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/

Локальность на целевой платформе можно замерить.
Профили:
- JIT. Приложение запускается в виртуальной среде, которая собирает профиль.
- Мутаторы. Внутри приложения находятся пробы, которые собирают профиль. Можно мониторить только определённые адреса, или только определённые функции.

**Пространственная локализация (spatial locality)** -- выделяем память, нарезаем его на блоки размером L, и проходим по всем блокам. Меняя размер блока L, и замеряя память, можно найти лучшее значение.

**Временная локализация (temporal locality)** -- на сколько часто мы к одному адресу обращаемся повторно. Моделируется блоками, к которым идёт обращение. Можно случайно менять индексы, которые определяют блок, к которому идёт обращение.

Тест APEX-map (memory access probe) -- построение карты локализации.

Есть задачи, которые обладают одной хорошей, но другой плохой локальностью.

### Асинхронные чтение/запись

Максимальная нагрузка на шину памяти. Многофазность операций ввода-вывода для параллельных обращений к памяти:
– выставление чтения (read issue)
– уступка/передача (yield)
– завершение чтения (read complete)

### Легковесные потоки для реализации асинхронности операций

Метод многофазного чтения -- реализация механизма многофазного чтения через легковесные потоки, не требующие переключения контекста процессора. Это ни потоки (threads) в терминах POSIX, ни задачи ядра Linux (tasks).

Один из методов введения легковесных потоков --  применение сопрограмм (coroutines)
