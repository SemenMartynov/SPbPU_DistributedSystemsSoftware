# Введение в многоязыковое программирование

## Способы вызова процедур

1. Управляемый код -- архитектурно независимый код, который выполняется под управлением среды (виртуальной машины)
   - языки семейства .net
   - JAVA Virtual Machine
   - Виртуальная машина для Андроид (Dalvik)
   - Иногда называют Python, но это интерпретируемый язык
2. Неуправляемый код (собственный, native) -- архитектурно зависимый код, компилируется под конкретную платформу

Ранее, в рамках одного проекта часть задач могла решаться на одном языке (`C`), часть на другом (`C++`).  Из обеих частей порождались объектные файлы, а далее на стадии компоновки происходила сборка единого файла. Второй подход -- порождение статической библиотеки, и статическая компоновка с ней.

## Статический подход

Компиляция в объектных файлов (`.OBJ`) и статическая компоновка (`.LIB`).

Преимущества -- наибольшая производительность и простота использования.  
Недостатки -- требования совместности на уровне компоновки и проверка на конфликтов имен.  
Создаются на языках с неуправляемым кодом.  
Вызываемы как из языков с неуправляемым кодом, так и из языков с управляемым.

При статической компоновке можно делать оптимизации: убрать из исполняемого файла не используемые символы! Это уменьшает размер исполняемого файла и снижает кэш-промахи.

## Динамический подход

Для Windows это `.dll` (Dynamic Link Library), для POSIX это `.so` (Shared Objects).

Преимущества -- эффективность (при использовании из большого числа языков), меньше шанс на конфликт имён.  
Недостатки -- сравнительно сложнее использовать в некоторых языках (многие популярные библиотеки распространяются и в статическом и в динамическом виде).  
Создаются на языках с неуправляемым кодом.  
Вызываемы как из языков с неуправляемым кодом, так и из языков с управляемым.

Эффективность достигается за счёт того, что популярная библиотека оказывается уже загруженной в оперативную память, и многие приложения могут обращаться к одному экземпляру.

## Управляемый код .Net (managed code assembly)

Преимущества -- архитектурно независимая среда реального времени (теоретически)  
Недостатки -- производительность, сложный интерфейс при вызове в неуправляемом коде.  
Создаются на языках с управляемым кодом.  
Вызываемы из других языков про помощи специальных интерфейсов.

## Процедуры

Процедуры -- общее понятие (включает и функции и подпрограммы). Но в некоторых языках (технологиях программирования) имеется путаница.

Функции -- вызов с возвращением результата.

Подпрограммы -- вид процедуры, введённый для совместимости между различными технологиями.

## Начальное значение индекса массива

C, С++, С# -- по умолчанию, начиная с 0 (из-за адресной арифметики);  
Fortran, Pascal, Delphi -- по умолчанию 1, но может быть другим.

## Развёртывание массивов в памяти

C, С++, С# -- по строкам (индексация по второму индексу).  
Pascal, Delphi -- по строкам (индексация по второму индексу).  
Fortran -- по столбцам (индексация по первому индексу).

Если технология предлагает один вид индексации, а алгоритм оптимальнее работает с другим, то можно просто поменять индексы местами: `B[j][i]`, где `j` номер столбца, а `i` номер строки.

## Схема работы JNI

Позволяет вызывать код через C-ABI (к примеру, код на Fortran).

Подобное взаимодействие требует понимания отображения типов JNI:

| Собственный  тип  | Тип Java     | Описание         |
|:----------------- |:------------ | ----------------:|
| unsigned char     | jboolean     | unsigned 8 bits  |
| signed char       | jbyte        | signed 8 bits    |
| unsigned short    | jchar        | unsigned 16 bits |
| short             | jshort       | signed 16 bits   |
| long              | jint         | signed 32 bits   |
| long long _int64  | jlong        | signed 64 bits   |
| float             | jgloat       | 32 bits          |
| double            | jdouble      | 64 bits          |
| void              |              |                  |


Недостатки JNI:
- Ошибки при работе с JNI приводят к нестабильности всей виртуальной машины
- Утрачивается основное преимущество Java -- кроссплатформенность; приходится делать разделяемые библиотеки под каждую платформу
- Автоматической сборки для не родной технологии нет, нужно явно очищать ресурсы

## Схема работы JNA

Методика взаимодействия на основе JNA
- В основе находится JNI
- Используется собственная библиотека libffi (foreign function interface library) для динамического вызова собственных методов
- Требует написание меньшего количества кода вручную (уменьшение вероятности ошибок)


| Собственный  тип  | Размер              | Тип Java        | Тип Windows   |
|:----------------- |:------------------- | --------------- | -------------:|
| char              | 8-bit integer       | byte            | BYTE, TCHAT   |
| short             | 16-bit              | short           | short WORD    |
| whar_t            | 16/32-bit character | char            | WCHAR, TCHAR  |
| int               | 32-int integer      | int             | DWORD         |
| int               | boolean value       | boolean         | BOOL          |
| long              | 32/64-bit integer   | NativeLong      | LONG          |
| long long, _int64 | 64-bit integer      | long            |               |
| float             | 32-bit FP           | float           |               |
| double            | 64-bit FP           | double          |               |
| char*             | C string            | String          | LPCTSTR       |
| void*             | pointer             | Pointer         | LPVOID, HANDLE|

Недостатки JNA:
- Для взаимодействия нужна "привязка", которая описывает интерфейс вызываемого символа. Для больших файлов писать тяжело.
- Изменения в исходной библиотеке приводит к изменению в привязках
- Документация автоматически для привязок не создаётся.

## Система динамических типов

Привязка может быть как для каждого вызываемого символа (множество привязок), так и для множества символов (одна общая привязка).

Автоматическая генерация привязок возможна при помощи GIR-scanner. Он проводит анализ кода и генерирует описание в XML либо в двоичном формате. В описании содержатся все встреченные символы, а также документация к этим символам. Это позволяет генерировать привязки и автоматизировать весь процесс. Можно это включить как этап для CI/CD.

Сложности -- довольно сложно работать. Каждый класс представляется двумя структурами: поля и указатели на методы.

Альтернативой может быть технология *Vala*. Это высокоуровневый язык для транслирования в GObject C. GIR-scanner может быть применен к коду на языке Valv.

## Методика самоанализа Vala

Шаги:
- Порождение файла GIR (GObject Introspection)
- Порождение файла vapi из файла GIR с помощью vapigen
- Настройка привязки в соотвествии с существующими метаданными и исполняемым кодом

Внедрение сильных сторон одного языка в другой язык делается через снабжение вызываемого кода привязкой с соглашением о вызовах C (C-ABI), несколько компиляций, компоновка и порождение динамической библиотеки. На Vala просто описываются внешние символы, и собираем код на Vala в динамическую библиотеку. При этом порождается GObject C и документация.

## Заключение

- Написание кода с соответствующей технологией позволяет порождать код высокого качества
- Команда разработки должна обладать соответствующей квалификацией (и это основная проблема)
- Необходимо озаботиться переносимостью привязок
- С точки зрения прибыли, качественное решение не всегда самое выгодное (иногда выгоднее раньше выйти на рынок)
- запуск собственного кода и векторизация не являются оптимизацией, это необходимое условие написание эффективного кода под целевую платформу.
